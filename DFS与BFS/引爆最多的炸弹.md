## 思路

- 判断炸弹 i 能否引爆炸弹 j：`isDetonates()`

若能引爆，只需要炸弹 i 与 炸弹 j 之间的距离小于炸弹 i 的爆炸范围半径：

```java
private boolean isDetonates(int i, int j, int[][] bombs) {
    long x = bombs[j][0] - bombs[i][0], y = bombs[j][1] - bombs[i][1];
    return x * x + y * y <= (long) bombs[i][2] * bombs[i][2];
}
```

- 构建有向图：`graph`

遍历每一个炸弹 i，`graph` 记录炸弹 i 能引爆的炸弹：

```java
// 构建有向图，i j 为不同炸弹
List<List<Integer>> graph = IntStream.range(0, bombs.length).mapToObj(i -> new ArrayList<Integer>()).collect(Collectors.toList());
for(int i = 0; i < bombs.length; i++) {
    for(int j = 0; j < bombs.length; j++) {
        if(i != j && isDetonates(i, j, bombs)) {
            graph.get(i).add(j);
        }
    }
}
```

- dfs函数设计

传入一个炸弹`u`，通过 `graph` 遍历炸弹`u`能引爆的其他炸弹，每引爆一个炸弹，用 `visited` 数组标记为`true`，再顺着引爆的炸弹`v`继续遍历炸弹`v`能引爆的炸弹...

索引函数设计为：

```java
private int dfs(int u, List<List<Integer>> graph, boolean[] visited) {
    visited[u] = true;
    // filter过滤掉还没引爆的炸弹，引爆的炸弹继续往下遍历
    return 1 + graph.get(u).stream().filter(v -> !visited[v]).mapToInt(v -> dfs(v, graph, visited)).sum();
}
```

## 代码

```java
class Solution {
    public int maximumDetonation(int[][] bombs) {
        // 构建有向图，i j 为不同炸弹
        List<List<Integer>> graph = IntStream.range(0, bombs.length).mapToObj(i -> new ArrayList<Integer>()).collect(Collectors.toList());
        for(int i = 0; i < bombs.length; i++) {
            for(int j = 0; j < bombs.length; j++) {
                if(i != j && isDetonates(i, j, bombs)) {
                    graph.get(i).add(j);
                }
            }
        }

        int ans = 0;
        // 遍历每一个炸弹，更新能引爆的最大数量
        for(int i = 0; i < bombs.length; i++) {
            ans = Math.max(dfs(i, graph, new boolean[bombs.length]), ans);
        }

        return ans;
    }

    private int dfs(int u, List<List<Integer>> graph, boolean[] visited) {
        visited[u] = true;
        // filter过滤掉还没引爆的炸弹，引爆的炸弹继续往下遍历
        return 1 + graph.get(u).stream().filter(v -> !visited[v]).mapToInt(v -> dfs(v, graph, visited)).sum();
    }

    // isDetonates：判断 炸弹i 能否引爆 炸弹j
    private boolean isDetonates(int i, int j, int[][] bombs) {
        long x = bombs[j][0] - bombs[i][0], y = bombs[j][1] - bombs[i][1];
        return x * x + y * y <= (long) bombs[i][2] * bombs[i][2];
    }
}
```

